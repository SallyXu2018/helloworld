### 复习

#### 创建对象的三种方式

```js
//对象：特指的某个事物，具有属性和方法，是一组无序属性的集合
//特征----属性
//行为----方法

//创建对象的三种方式
//1.字面量的方式
var per1={
    name:"sally",
    age:18,
    readBook:function () {
        console.log("aaaa");
    }
};
//2.调用系统函数的方式
var per2=new Object();
per2.name="cendy";
per2.age=19;
per2.run=function () {
    console.log("bbb");
};
console.log(per1 instanceof Object);//T
console.log(per2 instanceof Person);//F
//以上两种方式都属于object类型的


//3.自定义构造函数的方式
function Person(name,age) {
    this.name=name;
    this.age=age;
    this.play=function () {
        console.log("ccc");
    };
}
//创建对象--->实例化一个对象的同时对属性进行初始化
var per3=new Person("luna",20);
//1, 开辟空间存储对象
//2,把this值设置为当前的对象
//3,设置属性和方法的值
//4,把this对象返回
console.log(per3 instanceof Person);//T
```

#### 工厂模式创建对象

```js
function createPerson(name,age) {
    var obj=new Object();
    obj.name=name;
    obj.age=age;
    obj.sayHi=function () {
        console.log("oooo");
    };
    return obj;
}
var per=createPerson("sally",18);
console.log(per instanceof Object);
```

#### 自定义构造函数创建对象和工厂模式创建对象异同点

```js
 /*
* 共同点:都是函数,都可以创建对象,都可以传入参数
*
* 工厂模式:
* 函数名是小写
* 有new,
* 有返回值
* new之后的对象是当前的对象
* 直接调用函数就可以创建对象
*
* 自定义构造函数:
* 函数名是大写(首字母)
* 没有new
* 没有返回值
* this是当前的对象
* 通过new的方式来创建对象
* */
```

#### 实例对象和构造函数之间的关系

1. 实例对象是通过构造函数来创建的---创建的过程叫实例化

2. 如何判断对象是不是这个数据类型?

   1) 通过构造器的方式 实例对象.构造器==构造函数名字

   2) 对象 instanceof 构造函数名字

   尽可能的使用第二种方式来识别,为什么?原型讲完再说

#### 衔接

```js
/*
  * 面向过程和面向对象都是编程的思想,方式不一样
  * 面向过程:凡事都是亲力亲为,所有的代码都要自己写,每一步都要很清楚,注重的是过程
  * 面向对象:执行者成为指挥者,只要找对象,然后让对象做相关的事情,注重的是结果
  * 面向对象的特性:封装,继承,多态
  * 封装；就是代码的封装,把一些特征和行为封装在对象中.
  * 面向对象的编程思想:根据需求,抽象出相关的对象,总结对象的特征和行为,把特征变成属性，行为变成方法,然后定义(js)构造函数,实例化对象,通过对象调用属性和方法,完成相应的需求.---编程的思想
  *
  * 对象:具体特指的某个事物,有特征(属性)和行为(方法)，对象可以看成是一坨无序属性的集合
  *
  * 如何创建对象?
  * 通过调用new Object(),还有{},自定义构造函数
  *
  * 创建对象的方式
  * 1. 调用系统Object()----->创建出来的对象都是Object类型的,不能很明确的指出这个对象是属于什么类型
  * 2. 字面量的方式{}----->只能创建一个对象(一次只能创建一个)
  *
  * 3.工厂模式创建对象----->----->推论---->自定义构造函数的方式
  *   自定义构造函数(优化后的工厂模式)
  *
  *   自定义构造函数创建对象:4件事
  *   1.在内存中申请一块空闲的空间,存储创建的对象
  *   2.this就是当前实例化的对象
  *   3.设置对象中的属性和方法(为对象添加属性和方法,为属性和方法赋值)
  *   4.把创建后的对象返回
  *   都是需要通过new的方式
  *
  * 什么是原型?
  * 构造函数中有一个属性prototype,是原型,程序员使用的
  * 实例对象中有一个属性__proto__,是原型,浏览器使用的,不是很标准的,
  * 实例对象中的__proto__指向的就是该实例对象中的构造函数中的prototype
  * 构造函数中的prototype里面的属性或者方法,可以直接通过实例对象调用
  * 正常的写法:实例对象.__proto__才能访问到构造函数中的prototype中的属性或者方法
  * per.__proto__.eat();//__proto__不是标准的属性
  * per.eat();
  * 原型就是属性,而这个属性也是一个对象
  * Person.prototype--->是属性
  * Person.prototype.属性或者Person.ptototype.方法()
  *
  * 本身在构造函数中定义的属性和方法,当实例化对象的时候,实例对象中的属性和方法都是在自己的空间中存在的,如果是多个对象。这些属性和方法都会在单独的空间中存在,浪费内存空间,所以,为了数据共享,把想要节省空间的属性或者方法写在原型对象中,达到了数据共享，实现了节点内存空间
  *
  * 原型的作用之一:数据共享,节省内存空间
  *
  * 原型的写法:
  * 构造函数.prototype.属性=值
  * 构造函数.prototype.方法=值---->函数.prototype,函数也是对象,所以,里面也有__proto__
  * 实例对象.prototype-------->实例对象中没有这个属性,只有__proto__(暂时的)
  *
  * 简单的原型的写法
  * 缺陷:--->新的知识点---->原型直接指向{}---->就是一个对象,没有构造器
  * 构造函数.prototype={
  * 切记:如果这这种写法,要把构造器加上
  *
  * };
  *
  *
  * 通过原型为内置对象添加原型的属性或者方法----->原因:
  * 系统的内置对象的属性和方法可能不满足现在需求,所以,可以通过原型的方式加入属性或者方法,为了方便开发
  *
  * 为内置对象的原型中添加属性和方法,那么这个内置对象的实例对象就可以直接使用了
  * String.prototype.方法=匿名函数;
  * var str="哈哈";
  * str.方法();---->实例对象可以直接调用原型中的属性或者方法
  * */
```



## 面向对象编程

### 原型（既是属性又是方法）

#### 作用

一：数据共享，节省内存空间

```js
/*
* 实例对象中有个属性,__proto__,也是对象,叫原型,不是标准的属性,浏览器使用的
* 构造函数中有一个属性,prototype,也是对象,叫原型,是标准属性,程序员使用
*
* 原型---->__proto__或者是prototype,都是原型对象,
* 原型的作用:共享数据,节省内存空间
* */
```

#### 构造函数、原型对象、实例对象之间的关系

```js
/**
 * 构造函数可以实例化对象
 * 构造函数中有个属性叫做prototype，是构造函数的原型对象
 * 构造函数的原型对象中（prototype）中有个constructor构造器，这个构造器指向的就是自己所有在原型对象所在的构造函数
 * 实例对象的原型对象（__proto__）指向的是该构造函数的原型对象
 * 构造函数的原型对象（prototype）中的方法是可以被实例对象直接访问的
 *
 */
```

#### 什么样的数据是需要写在原型中的？

需要共享的数据写在原型对象中



### 局部变量变成全局变量

```js
//函数的自调用
//一次性函数--声明的同时，直接调用了
(function () {
    console.log("aa");
    var num=10;
})();
console.log(num);//报错
```

页面加载后，这个自调用函数的代码就执行完了
(function (形参) {
​    var num=10;//局部变量
})(实参);

```js
(function (window) {
    window.num=10;
})(window);
console.log(num);
```

### 案例-把随机数对象暴露给Windows成为全局变量

```js
//通过自调用函数长生一个随机数对象，在自调用函数外面，调用该随机数对象方法产生随机数
(function (window) {
    //产生随机数的构造函数
    function Random() {}
    //在原型对象中添加方法
    Random.prototype.getRandom=function (min,max) {
        return Math.floor(Math.random()*(max-min)+min)//0-4
    };
    //把Random对象暴露给顶级对象window--->外部可以直接使用这个对象
    window.Random=Random;
})(window);
var rm=new window.Random;
console.log(rm.getRandom(0,5));
```



### 面向对象游戏案例：贪吃蛇







## 继承









## 函数进阶













## 正则表达式
